---
editor: 
  markdown: 
    wrap: 72
---

# Comment utiliser/interroger un fichier parquet ? {.backgroundTitre}

## Lire un fichier avec read_parquet()

<br>

```{.r}
library(dplyr)
library(arrow)
library(tictoc)
```
<br>

Pour l'exemple, nous allons prendre une table d'une centaine de MO qui
contient 518 925 lignes et 486 colonnes.

```{.r}
RA2010 <- arrow::read_parquet("data/RA2010_exploitations.parquet")
> 2.56 sec elapsed
```

Le résultat obtenu est un objet directement utilisable dans R.  

Il est possible de sélectionner les colonnes que l'on souhaite importer dans R directement dans la fonction `read_parquet` :  

```{.r}
RA2010_extrait <- arrow::read_parquet("data/RA2010_exploitations.parquet",
                                      col_select = c("ID_DOSSIER","region","SAU"))
> 0.15 sec elapsed
```


## Comparaison avec la lecture d'un fichier rds

<br>

Voyons l'écart avec la lecture d'un fichier rds :

```{.r}
RA2010 <- readRDS("data/RA2010_exploitations.rds")
> 31.83 sec elapsed
```

<br>
<br>

- Le temps nécessaire au chargement de la table est d'environ 32 secondes
!
<br>
- L'écart est significatif rien que sur la lecture (X 13) et on n'a pas
commencé à manipuler des données !

## Lire et exploiter un fichier parquet volumineux

Exemple avec une table volumineuse (Recensements Insee 1968-2019, soit 51 millions de lignes et 18 colonnes) , suivre [ce lien](https://gist.github.com/ddotta/acf6add0f2328f077791461ef4f37b84) pour obtenir le code qui permet de générer “Ficdep19.parquet” de façon reproductible) :

```{.r}
# Établir la connexion aux données
donnees_Ficdep19 <- open_dataset("Data/Ficdep19.parquet")  |>
  filter(DEP_RES_21 == "11") |>
  group_by(SEXE) |>
  summarise(total = sum(pond)) |>
  collect()
```

Avec cette syntaxe, la requête va automatiquement utiliser les variables du fichier Parquet dont elle a besoin (en
l’occurence DEP_RES_21, SEXE et pond) et minimiser l’occupation de la mémoire vive.

## Des requêtes avec dplyr comme d'habitude

<br>

```{.r}
resultat <- RA2010 %>% 
  filter(region == "93") %>% 
  group_by(dep) %>% 
  summarise(total_SAU = sum(SAU, na.rm = TRUE))
  
# A tibble: 6 × 2
  dep   total_SAU
  <chr>     <dbl>
1 04     19348882
2 05     21368858
3 06      5564296
4 13     16531479
5 83      7387106
6 84     11344215
```

-   Le temps d'exécution de la requête est d'environ 9 secondes.
-   Les ressources consommées sont importantes

![](img/ressources_dplyr.png){fig-align="center"}
