---
editor: 
  markdown: 
    wrap: 72
---

# Manipuler des fichiers parquets avec duckdb {.backgroundTitre}

## Qu‚Äôest-ce que duckdb ?

DuckDB est un projet open-source qui propose un moteur SQL optimis√© pour **r√©aliser des travaux d‚Äôanalyse statistique sur des bases de donn√©es**.  

Plusieurs avantages :  

- Un **moteur portable** utilisable avec **plusieurs langages** (R, Python, Javascript...) et **plusieurs OS** (Windows, Linux, MacOS...)  
- Une **installation** et une **utilisation** tr√®s **facile**  

- Un **moteur SQL** capable d'utiliser des <u>donn√©es au format Parquet</u> **sans les charger compl√®tement en m√©moire**.  

::: callout-note

Il faut bien distinguer le projet DuckDB du package R duckdb qui propose simplement une fa√ßon d'utiliser Duckdb avec R.

:::


## √Ä quoi sert le package duckdb ?

Du point de vue d‚Äôun statisticien utilisant R, le package duckdb permet de faire trois choses:

- Importer des donn√©es (exemples: fichiers CSV, fichiers Parquet)  
- Manipuler des donn√©es avec la syntaxe dplyr, ou avec le langage SQL  
- √âcrire des donn√©es au format Parquet.  

## Alors arrow ou duckdb ?

Tableau repris de la documentation [utilitr](https://book.utilitr.org/)

| Je souhaite...                                                            | arrow | duckdb |
| ------------------------------------------------------------------------- | ----- | ------ |
| Optimiser mes traitements pour des donn√©es volumineuses                   | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Travailler sur un fichier .parquet ou .csv sans le charger enti√®rement en m√©moire | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser la syntaxe `dplyr` pour traiter mes donn√©es                      | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser du langage SQL pour traiter mes donn√©es                          | ‚ùå     | ‚úîÔ∏è     |
| Joindre des tables tr√®s volumineuses (plus de 4 Go)                          | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions fen√™tres (voir @sec-arrow)                          | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions statistiques qui n'existent pas dans arrow (voir @sec-arrow) | ‚ùå     | ‚úîÔ∏è     |
| √âcrire un fichier .parquet                                                | ‚úîÔ∏è     | ‚úîÔ∏è *   |

## Installation de duckdb

Il suffit d‚Äôinstaller le package duckdb, qui contient √† la fois DuckDB et une interface pour que R puisse s‚Äôy connecter.

Bonne nouvelle sur la version de Cerise mis √† disposition en 2025, le package duckdb sera install√© par d√©faut ! üéâüéâüéâ


## Connexions avec duckdb 

Pour utiliser duckdb, il n'est pas n√©cessaire de conna√Ætre le langage SQL car il est possible d'utiliser duckdb avec la syntaxe dplyr.  

duckdb est une base de donn√©es distante et s‚Äôutilise comme telle: il faut ouvrir une connexion, puis ‚Äúcharger‚Äù les donn√©es dans la base de donn√©es pour les manipuler.

```{.r}
con <- DBI::dbConnect(drv = duckdb::duckdb())
```

Plusieurs remarques :  

- Cette commande cr√©e une nouvelle base de donn√©es duckdb dans la m√©moire vive. 

- Cette base de donn√©es ne contient aucune donn√©e lorsqu‚Äôelle est cr√©√©e. L‚Äôobjet conn_ddb appara√Æt dans l‚Äôonglet Data de l‚Äôenvironnement RStudio, mais la liste des tables n‚Äôy est pas directement accessible

![](img/duckdb_fenetredata.png)
√Ä la fin du traitement ou du programme, on ferme la connexion avec le code ci-dessous. L‚Äôoption shutdown est importante : elle permet de fermer compl√®tement la session duckdb et de lib√©rer la m√©moire utilis√©e.

```{.r}
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Chargement de donn√©es issues de la session R (1/2)

La fonction `duckdb_register()` permet de charger dans duckdb des donn√©es pr√©sentes en m√©moire dans la session R.  

Cette m√©thode a l‚Äôavantage de ne pas recopier les donn√©es: elle se contente d‚Äô√©tablir un lien logique entre la base de donn√©es duckdb et un objet de la session R.  

L‚Äôobjet cr√©√© dans la base est **une vue** dans le catalogue "temp". La dur√©e d‚Äôexistence de cette vue est le temps de la connexion √† la base du fait qu‚Äôelle est dans un catalogue "temp".

```{.r}
# Cr√©ation de la vue "RA2020_duckdb"
con |> duckdb::duckdb_register(
  name = "RA2020_duckdb", 
  df = RA2020)
```

## Chargement de donn√©es issues de la session R (2/2)

Pour v√©rifier que le chargement des donn√©es a bien fonctionn√©, la fonction `tbl()` permet d'acc√©der √† une table de la base de donn√©es gr√¢ce √† son nom.  

```{.r}
con |> tbl("RA2020_duckdb")

# Source:   table<RA2020_duckdb> [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```

## Chargement de donn√©es sur le disque au format Parquet (1/2)

Comme pr√©cedemment la fonction `tbl()` peut √™tre directement utilis√©e.  

```{.r}
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
# Ou plus succinct (pas besoin de read_parquet() si pas besoin d'y passer des arguments)
con %>% tbl('data/RA2020_exploitations.parquet')

# Source:   SQL [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```


## Chargement de donn√©es sur le disque au format Parquet (2/2)

Avec des fichiers partitionn√©s, on peut utiliser la syntaxe suivante.  
`**/*.parquet` est un motif qui indique que vous souhaitez lire, dans tous les sous-dossiers quelque soit le niveau (`**`), l‚Äôensemble des fichiers parquets (`*.parquet`) qui s‚Äôy trouvent. 

```{.r}
con %>% tbl('data/msa_ns/**/*.parquet')

# Source:   SQL [?? x 293]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   A_IDENT         DEPT  RESID CANTON COMMUNE DOM_FISC SUP   NAF     SMI SITU_FAM NAIS_JO NAIS_MO NAIS_AN AF_MAJ AF_MIN AF_AVA
   <chr>           <chr> <chr> <chr>  <chr>      <dbl> <chr> <chr> <dbl>    <dbl> <chr>   <chr>   <chr>    <dbl>  <dbl>  <dbl>
 1 XXXXXXXXXXXXXX‚Ä¶ 11    11    10     288            1 0     NA        0        1 25      05      1969         0      0      0
 2 YYYYYYYYYYYYYY‚Ä¶ 11    11    01     281            1 2903  NA        0        1 30      01      2000         0      0      0
 3 ZZZZZZZZZZZZZZ‚Ä¶ 11    11    16     269            1 368   NA        0        1 07      01      2000         0      0      0
```

## Afficher la liste des tables d'une base Duckdb (1/2)

La fonction `dbListTables()` est utile pour afficher les noms des tables pr√©sente dans une base de donn√©es.  

Une illustration pour mieux comprendre :  

```{.r}
# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)

# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Affichage de la liste des tables
dbListTables(con)
# > character(0)

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
```

=> Question : combien de tables va maintenant renvoyer la fonction `dbListTables()` ?


## Afficher la liste des tables d'une base Duckdb (2/2)

R√©ponse... UNE SEULE !

```{.r}
# Affichage de la liste des tables
dbListTables(con)
# > "iris_duckdb"

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

En effet, lorsqu'on utilise la fonction `tbl()`, celle-ci ne charge pas les donn√©es 
ni dans la m√©moire de R ni dans celle de DuckDB.  

## Afficher la liste des colonnes d'une table d'une base Duckdb

La fonction `dbListFields()` est utile pour afficher les noms des colonnes d'une table pr√©sente dans une base de donn√©es.  
```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con |> DBI::dbListFields("iris_duckdb")
# > [1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"     

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Acc√©der aux m√©tadonn√©es d'un fichier parquet avec duckdb

En compl√©ment des instructions d√©j√† vues dans la partie 2 de la formation, on peut 
acc√©der aux m√©tadonn√©e d'un fichier Parquet en utilisant la requ√™te suivante :  

```{.r}
con <- dbConnect(duckdb())
dbGetQuery(con, "DESCRIBE FROM read_parquet('data/RA2020_exploitations.parquet')")

# >                 column_name column_type null  key default extra
1               NOM_DOSSIER     VARCHAR  YES <NA>    <NA>  <NA>
2        TYPE_QUESTIONNAIRE     VARCHAR  YES <NA>    <NA>  <NA>
3                 SEUIL_IFS     VARCHAR  YES <NA>    <NA>  <NA>
4                 CHAMP_GEO     VARCHAR  YES <NA>    <NA>  <NA>
...
```

## Requ√™tage avec dplyr

Le package R duckdb a √©t√© √©crit de fa√ßon √† pouvoir manipuler les donn√©es avec la syntaxe de dplyr, c'est tr√®s pratique !  

Comme avec le package {arrow} on utilise cette syntaxe avec les fonctions `collect()` ou `compute()`.

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# Traitement avec dplyr et un collect()
resultat <- RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```


## Comment acc√©der aux colonnes dans l'onglet environnement (TODO)

## duckplyr (TODO)