---
editor: 
  markdown: 
    wrap: 72
---

# Manipuler des fichiers parquets avec duckdb {.backgroundTitre}

## Qu‚Äôest-ce que duckdb ?

DuckDB est un projet open-source qui propose un moteur SQL optimis√© pour **r√©aliser des travaux d‚Äôanalyse statistique sur des bases de donn√©es**.  

Plusieurs avantages :  

- Un **moteur portable** utilisable avec **plusieurs langages** (R, Python, Javascript...) et **plusieurs OS** (Windows, Linux, MacOS...)  
- Une **installation** et une **utilisation** tr√®s **facile**  

- Un **moteur SQL** capable d'utiliser des <u>donn√©es au format Parquet</u> **sans les charger compl√®tement en m√©moire**.  

::: callout-note

Il faut bien distinguer <u>le projet DuckDB</u> du <u>package R duckdb</u> qui propose simplement une fa√ßon d'utiliser Duckdb avec R.

:::


## √Ä quoi sert le package duckdb + installation ?

<br>

**Du point de vue d‚Äôun statisticien utilisant R, le package duckdb permet de faire trois choses :**

- Importer des donn√©es (exemples: fichiers CSV, fichiers Parquet)  
- Manipuler des donn√©es avec la syntaxe dplyr, ou avec le langage SQL  
- √âcrire des donn√©es au format Parquet.  


**Installation de duckdb**

Il suffit d‚Äôinstaller le package duckdb, qui contient √† la fois DuckDB et une interface pour que R puisse s‚Äôy connecter.  


Bonne nouvelle sur la version de Cerise mis √† disposition en 2025, le package duckdb sera install√© par d√©faut ! üéâ


## Connexions avec duckdb 

<br>

**Pour utiliser duckdb, il n'est pas n√©cessaire de conna√Ætre le langage SQL car il est possible d'utiliser duckdb avec la syntaxe dplyr.**  

duckdb est une base de donn√©es distante et s‚Äôutilise comme telle : il faut ouvrir une connexion, puis ‚Äúcharger‚Äù les donn√©es dans la base de donn√©es pour les manipuler.  


```{.r}
con <- DBI::dbConnect(drv = duckdb::duckdb())
```

Plusieurs remarques :  

- Cette commande cr√©e une nouvelle base de donn√©es duckdb dans la m√©moire vive. 

- Cette base de donn√©es ne contient aucune donn√©e lorsqu‚Äôelle est cr√©√©e. L‚Äôobjet conn_ddb appara√Æt dans l‚Äôonglet Data de l‚Äôenvironnement RStudio, mais la liste des tables n‚Äôy est pas directement accessible

![](img/duckdb_fenetredata.png){fig-align="center"}

## D√©connexion avec duckdb

√Ä la fin du traitement ou du programme, on ferme la connexion avec le code ci-dessous. L‚Äôoption shutdown est importante : elle permet de fermer compl√®tement la session duckdb et de lib√©rer la m√©moire utilis√©e.

```{.r}
DBI::dbDisconnect(con, shutdown = TRUE)
```

::: callout-important

Si on n‚Äôutilise pas cette option, il arrive souvent que des connexions √† moiti√© ouvertes continuent √† consommer des ressources !!!

:::

## Chargement de donn√©es issues de la session R

La fonction `duckdb_register()` permet de charger dans duckdb des donn√©es pr√©sentes en m√©moire dans la session R.  

Cette m√©thode a l‚Äôavantage de ne pas recopier les donn√©es: elle se contente d‚Äô√©tablir un lien logique entre la base de donn√©es duckdb et un objet de la session R.  

L‚Äôobjet cr√©√© dans la base est **une vue** dans le catalogue "temp". La dur√©e d‚Äôexistence de cette vue est le temps de la connexion.

```{.r}
# Cr√©ation de la vue "RA2020_duckdb"
con |> duckdb::duckdb_register(
  name = "RA2020_duckdb", 
  df = RA2020)
```

## Acc√©der √† une table d'une base DuckDB

Pour v√©rifier que le chargement des donn√©es a bien fonctionn√©, la fonction `tbl()` permet d'acc√©der √† une table de la base de donn√©es gr√¢ce √† son nom.  

```{.r}
con |> tbl("RA2020_duckdb")

# Source:   table<RA2020_duckdb> [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```

## Chargement de donn√©es sur le disque au format Parquet (1/2)

Comme pr√©cedemment la fonction `tbl()` peut √™tre directement utilis√©e.  

```{.r}
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
# Ou plus succinct (pas besoin de read_parquet() si pas besoin d'y passer des arguments)
con %>% tbl('data/RA2020_exploitations.parquet')

# Source:   SQL [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```


## Chargement de donn√©es sur le disque au format Parquet (2/2)

Avec des fichiers partitionn√©s, on peut utiliser la syntaxe suivante.  
`**/*.parquet` est un motif qui indique que vous souhaitez lire, dans tous les sous-dossiers quelque soit le niveau (`**`), l‚Äôensemble des fichiers parquets (`*.parquet`) qui s‚Äôy trouvent. 

```{.r}
con %>% tbl('data/msa_ns/**/*.parquet')

# Source:   SQL [?? x 293]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   A_IDENT         DEPT  RESID CANTON COMMUNE DOM_FISC SUP   NAF     SMI SITU_FAM NAIS_JO NAIS_MO NAIS_AN AF_MAJ AF_MIN AF_AVA
   <chr>           <chr> <chr> <chr>  <chr>      <dbl> <chr> <chr> <dbl>    <dbl> <chr>   <chr>   <chr>    <dbl>  <dbl>  <dbl>
 1 XXXXXXXXXXXXXX‚Ä¶ 11    11    10     288            1 0     NA        0        1 25      05      1969         0      0      0
 2 YYYYYYYYYYYYYY‚Ä¶ 11    11    01     281            1 2903  NA        0        1 30      01      2000         0      0      0
 3 ZZZZZZZZZZZZZZ‚Ä¶ 11    11    16     269            1 368   NA        0        1 07      01      2000         0      0      0
```

## Afficher la liste des tables d'une base Duckdb (1/2)

La fonction `dbListTables()` est utile pour afficher les noms des tables pr√©sente dans une base de donn√©es.  

Une illustration pour mieux comprendre :  

```{.r}
# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)

# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Affichage de la liste des tables
dbListTables(con)
# > character(0)

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
```

=> Question : combien de tables va maintenant renvoyer la fonction `dbListTables()` ?


## Afficher la liste des tables d'une base Duckdb (2/2)

R√©ponse... UNE SEULE !

```{.r}
# Affichage de la liste des tables
dbListTables(con)
# > "iris_duckdb"

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

En effet, lorsqu'on utilise la fonction `tbl()`, celle-ci ne charge pas les donn√©es 
ni dans la m√©moire de R ni dans celle de DuckDB.  

## Afficher la liste des colonnes d'une table d'une base Duckdb

La fonction `dbListFields()` est utile pour afficher les noms des colonnes d'une table pr√©sente dans une base de donn√©es.  
```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con |> DBI::dbListFields("iris_duckdb")
# > [1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"     

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Acc√©der aux m√©tadonn√©es d'un fichier parquet avec duckdb

En compl√©ment des instructions d√©j√† vues dans la partie 2 de la formation, on peut 
acc√©der aux m√©tadonn√©e d'un fichier Parquet en utilisant la requ√™te suivante :  

```{.r}
con <- DBI::dbConnect(drv = duckdb::duckdb())
dbGetQuery(con, "DESCRIBE FROM read_parquet('data/RA2020_exploitations.parquet')")

# >                 column_name column_type null  key default extra
1               NOM_DOSSIER     VARCHAR  YES <NA>    <NA>  <NA>
2        TYPE_QUESTIONNAIRE     VARCHAR  YES <NA>    <NA>  <NA>
3                 SEUIL_IFS     VARCHAR  YES <NA>    <NA>  <NA>
4                 CHAMP_GEO     VARCHAR  YES <NA>    <NA>  <NA>
...
```

Remarque : La fonction dbGetQuery() du package DBI permet de r√©cup√©rer un data.frame dont le contenu est le r√©sultat d‚Äôune requ√™te.  


## Requ√™tage avec dplyr

Le package R duckdb a √©t√© √©crit de fa√ßon √† pouvoir manipuler les donn√©es avec la syntaxe de dplyr, c'est tr√®s pratique !  

Comme avec le package {arrow} on utilise cette syntaxe avec les fonctions `collect()` ou `compute()`.

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# Traitement avec dplyr et un collect()
resultat <- RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Examen de la requ√™te SQL construite par duckdb

Quand on manipule des objets avec duckdb, on construit des requ√™tes SQL.  
Le package duckdb se contente de traduire le code dplyr en SQL.  
La fonction `show_query()` permet de consulter la requ√™te SQL qui a √©t√© ex√©cut√©e par duckdb.  

```{.r}
# Traitement avec dplyr et un collect()
resultat <- RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  show_query()
  
# > <SQL>
SELECT SIEGE_DEP, SUM(SAU_TOT) AS total_SAU
FROM "data/RA2020_exploitations.parquet"
WHERE (SIEGE_REG = '93')
GROUP BY SIEGE_DEP
```

## Requ√™tage avec SQL

Si vous avez des connaissances en SQL, il est bien s√ªr tout √† fait possible 
de requ√™ter une base DuckDB avec ce langage.  
La requ√™te est alors pass√©e dans la fonction `DBI::dbGetQuery()` :  

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

chemin_donnees <- 'C:/Users/damien.dotta/DEMESIS/Formations_R/Formation_R_perfectionnement/formation-R-perf-06-parquet/data'

# Execution de la requete
resultatSQL <- DBI::dbGetQuery(
   con,
   paste0("SELECT SIEGE_DEP, SUM(SAU_TOT) AS total_SAU
    FROM '", file.path(chemin_donnees,'RA2020_exploitations.parquet'),"'
    WHERE (SIEGE_REG = '93')
    GROUP BY SIEGE_DEP"))
# resultatSQL est un data.frame directement utilisable dans R
```

## Sauvegarder des r√©sultats interm√©diaires - dans des fichiers Parquet

Lorsque le traitement est long, vous devez le d√©couper et stocker quelque part vos r√©sulats 
interm√©diaires de mani√®re √† ne pas tout recalculer enti√®rement √† chaque fois.  

1. Une 1√®re solution consiste √† √©crire ces r√©sultats interm√©diaires dans des fichiers Parquet :

```{.r}
# On cr√©e une nouvelle connexion + cr√©ation d'une BDD vide avec le param√®tre dbdir
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# A la fin du traitement, on √©crit un fichier parquet interm√©diaire 
RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  arrow::to_arrow() |>          # Conversion dans un format compatible avec arrow
  arrow::write_parquet("data/table_intermediaire.parquet")
  
# Reprise des traitements + tard avec le moteur SQL de duckdb
final <- arrow::open_dataset("data/table_intermediaire.parquet") |>
  arrow::to_duckdb(con) |>  # Conversion dans un format compatible avec duckdb
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Sauvegarder des r√©sultats interm√©diaires - avec une BDD

2. Une 2√®me solution consiste √† √©crire dans une BDD ces r√©sultats interm√©diaires :

```{.r}
# On cr√©e une nouvelle connexion + cr√©ation d'une BDD vide avec le param√®tre dbdir
con <- DBI::dbConnect(drv = duckdb::duckdb(),
                      dbdir = "data/BDD_formation.db")

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# suppression des tables cr√©√©s
DBI::dbRemoveTable(con, "resultat_interm")

# Traitement avec dplyr et un collect()
RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  compute(name = "resultat_interm",
          temporary = FALSE)

# Affichage de la liste des tables
dbListTables(con)
# [1] "resultat_interm"

# Reprise des traitements + tard avec le moteur SQL de duckdb
final2 <- con |> tbl("resultat_interm") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## A retenir sur les 2 m√©thodes de sauvegarde des r√©sultats interm√©diaires

<br>

-La premi√®re m√©thode avec **{arrow} et la sauvegarde dans des fichiers Parquet** est g√©n√©ralement **la plus rapide**.  

<br>

- La seconde avec **compute() et la sauvegarde dans une BDD** est **la plus efficace en terme d‚Äôoccupation m√©moire**.

## Options √† utiliser

Lors d'une connexion √† une base, des param√®tres de `dbConnect()` peuvent √™tre tr√®s utiles lorsqu'on travaille sur un espace comme Cerise o√π les ressources sont partag√©es.  
Par exemple :  

```{.r}
con_dbnew <- dbConnect(
  drv = duckdb::duckdb(),
  dbdir=db_file,
  config=list("memory_limit"="10GB", # On d√©finit un plafond de 10Go de RAM
              threads = "4")) # On plafonne l'utilise par duckdb de 4 coeurs (sur les 30 dispos sur Cerise)
```

## Pour finir, une comparaison entre {arrow} et {duckdb} (1/2)

Tableau repris de la documentation [utilitr](https://book.utilitr.org/).


| Je souhaite...                                                            | arrow | duckdb |
| ------------------------------------------------------------------------- | ----- | ------ |
| Optimiser mes traitements pour des donn√©es volumineuses                   | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Travailler sur un fichier .parquet ou .csv sans le charger enti√®rement en m√©moire | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser la syntaxe `dplyr` pour traiter mes donn√©es                      | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser du langage SQL pour traiter mes donn√©es                          | ‚ùå     | ‚úîÔ∏è     |
| Joindre des tables tr√®s volumineuses (plus de 4 Go)                          | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions fen√™tres (voir @sec-arrow)                          | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions statistiques qui n'existent pas dans arrow (voir @sec-arrow) | ‚ùå     | ‚úîÔ∏è     |
| √âcrire un fichier .parquet                                                | ‚úîÔ∏è     | ‚úîÔ∏è     |

## Pour finir, une comparaison entre {arrow} et {duckdb} (2/2)

{arrow} et {duckdb} partagent de nombreux concepts. Voici quelques diff√©rences :  

- **{duckdb} comprend parfaitement SQL**. Si vous √™tes √† l'aise avec ce langage, vous ne serez pas d√©pays√©s.  

- Le projet duckdb est tr√®s r√©cent. Il y a r√©guli√®rement des √©volutions qui sont souvent des extensions ou des optimisations, et parfois la r√©solution de bugs. **arrow est un projet plus ancien et plus mature**.  

- La couverture fonctionnelle des fonctions standards de R est meilleure sur {duckdb} que sur {arrow}.  
Il est pr√©f√©rable d'utiliser {duckdb} pour les jointures de tables volumineuses.  
De m√™me, les fonctions pivot_wider(), pivot_longer() et les windows_function existent nativement dans duckdb mais pas dans arrow.

Par exemple, arrow ne peut pas ajouter directement √† la base permanente des √©quipements une colonne √©gale au nombre total d‚Äô√©quipements du d√©partement. Le code fonctionne en duckdb.

```{.r}
# arrow ne peut pas ex√©cuter ceci
bpe_ens_2022_dataset |>
  group_by(DEP) |>
  mutate(NB_EQUIP_TOTAL_DEP  = sum(NB_EQUIP)) |>
  select(DEP, NB_EQUIP, NB_EQUIP_TOTAL_DEP)

# Source:   SQL [?? x 3]
# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1024-azure:R 4.3.2/:memory:]
# Groups:   DEP
   DEP   NB_EQUIP NB_EQUIP_TOTAL_DEP
   <chr>    <dbl>              <dbl>
 1 09           2               7316
 2 09           3               7316
# ‚Ñπ more rows
```


## Comment acc√©der aux colonnes dans l'onglet environnement (TODO)

## Pour aller plus loin : le package duckplyr

To DO OU PAS (UN AVIS ?)