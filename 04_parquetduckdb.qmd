---
editor: 
  markdown: 
    wrap: 72
---

# Manipuler des fichiers parquets avec duckdb {.backgroundTitre}

## Qu'est-ce que duckdb ?

DuckDB est un projet open-source qui propose un moteur SQL optimis√© pour **r√©aliser des travaux d'analyse statistique sur des bases de donn√©es**.  

Plusieurs avantages :  

- Un **moteur portable** utilisable avec **plusieurs langages** (R, Python, Javascript...) et **plusieurs OS** (Windows, Linux, MacOS...)  
- Une **installation** et une **utilisation** tr√®s **facile**  

- Un **moteur SQL** capable d'utiliser des <u>donn√©es au format Parquet</u> **sans les charger compl√®tement en m√©moire**.  

::: callout-note

Il faut bien distinguer <u>le projet DuckDB</u> du <u>package R duckdb</u> qui propose simplement une fa√ßon d'utiliser Duckdb avec R.

:::


## √Ä quoi sert le package duckdb + installation ?

<br>

**Du point de vue d'un statisticien utilisant R, le package duckdb permet de faire trois choses :**

- Importer des donn√©es (exemples: fichiers CSV, fichiers Parquet)  
- Manipuler des donn√©es avec la syntaxe dplyr, ou avec le langage SQL  
- √âcrire des donn√©es au format Parquet.  


**Installation de duckdb**

Il suffit d'installer le package duckdb, qui contient √† la fois DuckDB et une interface pour que R puisse s'y connecter.  


Bonne nouvelle sur la version de Cerise mis √† disposition en 2025, le package duckdb sera install√© par d√©faut ! üéâ


## Connexions avec duckdb 

<br>

**Pour utiliser duckdb, il n'est pas n√©cessaire de conna√Ætre le langage SQL car il est possible d'utiliser duckdb avec la syntaxe dplyr.**  

duckdb est une base de donn√©es distante et s'utilise comme telle : il faut ouvrir une connexion, puis ‚Äúcharger‚Äù les donn√©es dans la base de donn√©es pour les manipuler.  


```{.r}
con <- DBI::dbConnect(drv = duckdb::duckdb())
```

Plusieurs remarques :  

- Cette commande cr√©e une nouvelle base de donn√©es duckdb **dans la m√©moire vive**. 

- Cette base de donn√©es ne contient aucune donn√©e lorsqu'elle est cr√©√©e. L'objet `con` appara√Æt dans l'onglet Data de l'environnement RStudio, mais la liste des tables n'y est pas directement accessible

![](img/duckdb_fenetredata.png){fig-align="center"}

## D√©connexion avec duckdb

<br>

√Ä la fin du traitement ou du programme, on ferme la connexion avec le code ci-dessous. L'option `shutdown` est importante : elle permet de fermer compl√®tement la session duckdb et de lib√©rer la m√©moire utilis√©e.  



```{.r}
DBI::dbDisconnect(con, shutdown = TRUE)
```

<br>

::: callout-important

Si on n'utilise pas cette option, il arrive souvent que des connexions √† moiti√© ouvertes continuent √† consommer des ressources !!!

:::

## Chargement de donn√©es issues de la session R

**La fonction `duckdb_register()` permet de charger dans duckdb des donn√©es pr√©sentes en m√©moire dans la session R.**  

<br>

Cette m√©thode a l'avantage de ne pas recopier les donn√©es: elle se contente d'√©tablir un lien logique entre la base de donn√©es duckdb et un objet de la session R.  

L'objet cr√©√© dans la base est **une vue** dans le catalogue "temp". La dur√©e d'existence de cette vue est le temps de la connexion.

<br>

```{.r}
# Cr√©ation de la vue "RA2020_duckdb"
con |> duckdb::duckdb_register(
  name = "RA2020_duckdb", 
  df = RA2020)
```

## Acc√©der √† une table d'une base DuckDB

<br>

Pour v√©rifier que le chargement des donn√©es a bien fonctionn√©, **la fonction `tbl()` permet d'acc√©der √† une table de la base de donn√©es gr√¢ce √† son nom (entre double quotes).**

<br>

```{.r}
con |> tbl("RA2020_duckdb")

# Source:   table<RA2020_duckdb> [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```

## Chargement de donn√©es sur le disque au format Parquet (1/2)

<br>

Pour charger des donn√©es situ√©s sur Cerise par exemple, la fonction `tbl()` peut aussi √™tre directement utilis√©e en renseignant le chemin du fichier Parquet.  

<br>

```{.r}
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
# Ou plus succinct (pas besoin de read_parquet() si pas besoin d'y passer des arguments)
con %>% tbl('data/RA2020_exploitations.parquet')

# Source:   SQL [?? x 255]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   NOM_DOSSIER TYPE_QUESTIONNAIRE SEUIL_IFS CHAMP_GEO COEF_F NUMSTRATE  STRATE     SIEGENAT SIEGE_CODE_COM SIEGE_LIEUDIT      
   <chr>       <chr>              <chr>     <chr>      <dbl> <chr>      <chr>      <chr>    <chr>          <chr>              
 1 AAAAAAA     2                  1         1           1.22 2500000004 25000ERICA 10       14406          NA                 
 2 BBBBBBB     2                  1         1          10.3  2105161843 2105161843 10       51303          NA                 
 3 CCCCCCC     3                  1         2           1    0101030406 EXH_GEO    10       97407          CHEMIN DES ANGLAIS 
```


## Chargement de donn√©es sur le disque au format Parquet (2/2)

<br>

Avec des fichiers partitionn√©s, on peut utiliser la syntaxe suivante.  
`**/*.parquet` est un motif qui indique que vous souhaitez lire, dans tous les sous-dossiers quelque soit le niveau (`**`), l'ensemble des fichiers parquets (`*.parquet`) qui s'y trouvent.  

<br>

```{.r}
con %>% tbl('data/msa_ns/**/*.parquet')

# Source:   SQL [?? x 293]
# Database: DuckDB v1.1.0 [damien.dotta@Windows 10 x64:R 4.3.0/:memory:]
   A_IDENT         DEPT  RESID CANTON COMMUNE DOM_FISC SUP   NAF     SMI SITU_FAM NAIS_JO NAIS_MO NAIS_AN AF_MAJ AF_MIN AF_AVA
   <chr>           <chr> <chr> <chr>  <chr>      <dbl> <chr> <chr> <dbl>    <dbl> <chr>   <chr>   <chr>    <dbl>  <dbl>  <dbl>
 1 XXXXXXXXXXXXXX‚Ä¶ 11    11    10     288            1 0     NA        0        1 25      05      1969         0      0      0
 2 YYYYYYYYYYYYYY‚Ä¶ 11    11    01     281            1 2903  NA        0        1 30      01      2000         0      0      0
 3 ZZZZZZZZZZZZZZ‚Ä¶ 11    11    16     269            1 368   NA        0        1 07      01      2000         0      0      0
```

## Afficher la liste des tables d'une base Duckdb (1/2)

La fonction `dbListTables()` est utile pour afficher les noms des tables pr√©sentes dans une base de donn√©es.  

Une illustration pour mieux comprendre :  

```{.r}
# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)

# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Affichage de la liste des tables
dbListTables(con)
# > character(0)

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con %>% tbl("read_parquet('data/RA2020_exploitations.parquet')")
```

=> Question : combien de tables va maintenant renvoyer la fonction `dbListTables()` ?


## Afficher la liste des tables d'une base Duckdb (2/2)

<br>

R√©ponse... UNE SEULE !

```{.r}
# Affichage de la liste des tables
dbListTables(con)
# > "iris_duckdb"

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

<br>

**En effet, lorsqu'on utilise la fonction `tbl()`, celle-ci ne charge pas les donn√©es 
ni dans la m√©moire de R ni dans celle de DuckDB.**  

## Afficher la liste des colonnes d'une table d'une base Duckdb

<br>

La fonction `dbListFields()` est utile pour afficher les noms des colonnes d'une table pr√©sente dans une base de donn√©es. 

<br>

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

con |> duckdb::duckdb_register(
  name = "iris_duckdb", 
  df = iris)
  
con |> DBI::dbListFields("iris_duckdb")
# > [1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"     

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```

## Acc√©der aux logical_types des colonnes d'un fichier parquet avec duckdb

<br>

En compl√©ment des instructions d√©j√† vues dans la partie 2 de la formation, on peut 
acc√©der aux logical_types des colonnes d'un fichier Parquet en utilisant la requ√™te suivante :  

<br>

```{.r}
con <- DBI::dbConnect(drv = duckdb::duckdb())
dbGetQuery(con, "DESCRIBE FROM read_parquet('data/ouptut.parquet')")

# column_name column_type null  key default extra
# 1    colonne1      DOUBLE  YES <NA>    <NA>  <NA>
# 2    colonne2     VARCHAR  YES <NA>    <NA>  <NA>
# 3    colonne3     BOOLEAN  YES <NA>    <NA>  <NA>
# 4    colonne4        DATE  YES <NA>    <NA>  <NA>
```

<br>

Remarque : **La fonction dbGetQuery() du package DBI permet de r√©cup√©rer un data.frame dont le contenu est le r√©sultat d'une requ√™te.**  


## Requ√™tage avec dplyr

Le package R duckdb a √©t√© √©crit de fa√ßon √† pouvoir manipuler les donn√©es avec la syntaxe de dplyr, c'est tr√®s pratique !  

Comme avec le package {arrow} on utilise cette syntaxe avec les fonctions `collect()` ou `compute()`.

::: columns

::: {.column width="50%"}

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# Traitement avec dplyr et un collect()
resultat <- RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```
:::

::: {.column width="50%"}

```{.r}
> resultat
# A tibble: 6 √ó 2
  SIEGE_DEP total_SAU
  <chr>         <dbl>
1 84          112888.
2 05           91979.
3 04          158946.
4 13          145713.
5 83           77785.
6 06           41141.
```
:::

::::


## Examen de la requ√™te SQL construite par duckdb

Quand on manipule des objets avec duckdb, on construit des requ√™tes SQL.  
Le package duckdb se contente de traduire le code dplyr en SQL.  
La fonction `show_query()` permet de consulter la requ√™te SQL qui a √©t√© ex√©cut√©e par duckdb.  

<br>

```{.r}
# Traitement avec dplyr et un collect()
resultat <- RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  show_query()
  
# > <SQL>
SELECT SIEGE_DEP, SUM(SAU_TOT) AS total_SAU
FROM "data/RA2020_exploitations.parquet"
WHERE (SIEGE_REG = '93')
GROUP BY SIEGE_DEP
```

## Requ√™tage avec SQL

Si vous avez des connaissances en SQL, il est bien s√ªr tout √† fait possible 
de requ√™ter une base DuckDB avec ce langage.  
La requ√™te est alors pass√©e dans la fonction `DBI::dbGetQuery()` :  

<br>

```{.r}
# On cr√©e une nouvelle connexion
con <- DBI::dbConnect(drv = duckdb::duckdb())

chemin_donnees <- 'C:/Users/damien.dotta/DEMESIS/Formations_R/Formation_R_perfectionnement/formation-R-perf-06-parquet/data'

# Execution de la requete
resultatSQL <- DBI::dbGetQuery(
   con,
   paste0("SELECT SIEGE_DEP, SUM(SAU_TOT) AS total_SAU
    FROM '", file.path(chemin_donnees,'RA2020_exploitations.parquet'),"'
    WHERE (SIEGE_REG = '93')
    GROUP BY SIEGE_DEP"))
# resultatSQL est un data.frame directement utilisable dans R
```

## Sauvegarder des r√©sultats interm√©diaires - dans des fichiers Parquet

**Lorsque le traitement est long, vous devez le d√©couper et stocker quelque part vos r√©sulats 
interm√©diaires de mani√®re √† ne pas tout recalculer enti√®rement √† chaque fois.**  

1. Une 1√®re solution consiste √† √©crire ces r√©sultats interm√©diaires dans des fichiers Parquet :

::: columns

::: {.column width="50%"}
```{.r}
# On cr√©e une nouvelle connexion 
con <- DBI::dbConnect(drv = duckdb::duckdb())

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# A la fin du traitement, on √©crit un fichier parquet interm√©diaire 
RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  # Conversion dans un format compatible avec arrow
  arrow::to_arrow() |>          
  arrow::write_parquet("data/table_intermediaire.parquet")
```
:::

::: {.column width="50%"}
```{.r}
# Reprise des traitements + tard avec le moteur SQL de duckdb
final <- arrow::open_dataset("data/table_intermediaire.parquet") |>
  # Conversion dans un format compatible avec duckdb
  arrow::to_duckdb(con) |>  
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```
:::

::::


## Sauvegarder des r√©sultats interm√©diaires - avec une BDD

2. Une 2√®me solution consiste √† √©crire dans une BDD ces r√©sultats interm√©diaires :

::: columns

::: {.column width="50%"}
```{.r}
# On cr√©e une nouvelle connexion 
# + cr√©ation d'une BDD vide avec le param√®tre dbdir
con <- DBI::dbConnect(drv = duckdb::duckdb(),
                      dbdir = "data/BDD_formation.db")

# Etablissement de la connexion au fichier Parquet
RA2020_dataset <- con %>% tbl('data/RA2020_exploitations.parquet')

# Traitement avec dplyr et un compute()
RA2020_dataset |>
  filter(SIEGE_REG == "93") |> 
  compute(name = "resultat_interm",
          temporary = FALSE)
          
# suppression des tables cr√©√©s
DBI::dbRemoveTable(con, "resultat_interm")
```
:::

::: {.column width="50%"}
```{.r}
# Affichage de la liste des tables
dbListTables(con)
# [1] "resultat_interm"

# Reprise des traitements + tard avec le moteur SQL de duckdb
final2 <- con |> tbl("resultat_interm") |> 
  group_by(SIEGE_DEP) |> 
  summarise(total_SAU = sum(SAU_TOT, na.rm = TRUE)) |> 
  collect()

# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```
:::

::::


## A retenir sur les 2 m√©thodes de sauvegarde des r√©sultats interm√©diaires

<br>

- La premi√®re m√©thode avec **{arrow} et la sauvegarde dans des fichiers Parquet** est g√©n√©ralement **la plus rapide**.  

<br>

- La seconde avec **compute() et la sauvegarde dans une BDD** est **la plus efficace en terme d'occupation m√©moire**.

## Options √† utiliser

<br>

Lors d'une connexion √† une base, des param√®tres de `dbConnect()` peuvent √™tre tr√®s utiles lorsqu'on travaille sur un espace comme Cerise o√π les ressources sont partag√©es.  

Par exemple :  

<br>

```{.r}
con_dbnew <- dbConnect(
  drv = duckdb::duckdb(),
  dbdir=db_file,
  config=list("memory_limit"="10GB", # On d√©finit un plafond de 10Go de RAM
              threads = "4")) # On plafonne l'utilise par duckdb de 4 coeurs (sur les 30 dispos sur Cerise)
```

## Consulter le contenu d'une base

Reprenons la base `BDD_formation.db` cr√©√©e pr√©c√©demment.  

::: columns

::: {.column width="50%"}
```{.r}
# On cr√©e une nouvelle connexion 
con <- DBI::dbConnect(drv = duckdb::duckdb(),
                      dbdir = "data/BDD_formation.db")

# Affichage de la liste des tables
dbListTables(con)
# > [1] "resultat_interm"
```

Ajoutons-y une vue :  
<br>

```{.r}
# Cr√©ation de la vue "RA2020_duckdb"
con |> duckdb::duckdb_register(
  name = "RA2020_duckdb", 
  df = RA2020)
```
:::

::: {.column width="50%"}
```{.r}
# Affichage de la liste des tables
dbListTables(con)
# > [1] "RA2020_duckdb"   "resultat_interm"
```
Qu'en est-il vraiment ?
<br>

```{.r}
DBI::dbGetQuery(con,"SELECT * FROM INFORMATION_SCHEMA.TABLES")
# table_catalog table_schema      table_name table_type 
1 BDD_formation         main resultat_interm BASE TABLE
2          temp         main   RA2020_duckdb       VIEW
```

=> Apr√®s d√©connexion, seule la table "resultat_interm" sera conserv√©e dans la BDD.

```{.r}
# On se d√©connecte
DBI::dbDisconnect(con, shutdown = TRUE)
```
:::

::::

## Exercice 3

::: {.callout-tip icon="false"}
## Exercice 3 (manipulation avec duckdb)

-   Avec duckdb, se connecter au fichier du RA2020 au format Parquet (cf. exercice 1)

-   Filtrer la table du RA2020 EXPLOITATIONS sur la r√©gion de votre choix (SIEGE_REG) puis calculer la moyenne de la SAU (SAU_TOT) en fonction de l'orientation nomenclature agr√©g√©e (OTEFDA_COEF17).

-   R√©aliser le m√™me traitement que pr√©c√©demment mais sur une r√©gion diff√©rente.

-   Fusionner les 2 tables cr√©√©es aux questions pr√©c√©dentes de mani√®re √† avoir une table qui se pr√©sente sous la forme suivante :

![](img/exercice3_resultats.png){fig-align="center"}
<br>
-   Re-faites l'exercice avec SQL (ou la syntaxe dplyr)
:::

## Pour finir, une comparaison entre {arrow} et {duckdb} (1/2)

Tableau repris de la documentation [utilitr](https://book.utilitr.org/).


| Je souhaite...                                                            | arrow | duckdb |
| ------------------------------------------------------------------------- | ----- | ------ |
| Optimiser mes traitements pour des donn√©es volumineuses                   | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Travailler sur un fichier .parquet ou .csv sans le charger enti√®rement en m√©moire | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser la syntaxe `dplyr` pour traiter mes donn√©es                      | ‚úîÔ∏è     | ‚úîÔ∏è     |
| Utiliser du langage SQL pour traiter mes donn√©es                          | ‚ùå     | ‚úîÔ∏è     |
| Joindre des tables tr√®s volumineuses (plus de 4 Go)                          | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions fen√™tres                         | ‚ùå     | ‚úîÔ∏è     |
| Utiliser des fonctions statistiques qui n'existent pas dans arrow        | ‚ùå     | ‚úîÔ∏è     |
| √âcrire un fichier .parquet                                                | ‚úîÔ∏è     | ‚úîÔ∏è     |

## Pour finir, une comparaison entre {arrow} et {duckdb} (2/2)

{arrow} et {duckdb} partagent de nombreux concepts. Voici quelques diff√©rences :  

- **{duckdb} comprend parfaitement SQL**. Si vous √™tes √† l'aise avec ce langage, vous ne serez pas d√©pays√©s.  

- Le projet duckdb est tr√®s r√©cent. Il y a r√©guli√®rement des √©volutions qui sont souvent des extensions ou des optimisations, et parfois la r√©solution de bugs. **arrow est un projet plus ancien et plus mature**.  

- **La couverture fonctionnelle des fonctions standards de R est meilleure sur {duckdb} que sur {arrow}.**  
<u>Il est pr√©f√©rable d'utiliser {duckdb} pour les jointures de tables volumineuses.</u>  
De m√™me, les fonctions `pivot_wider()`, `pivot_longer()` et les `windows_function` existent nativement dans duckdb mais pas dans arrow. Par exemple :

::: columns

::: {.column width="50%"}
```{.r}
# arrow ne peut pas ex√©cuter ceci
bpe_ens_2022_dataset |>
  group_by(DEP) |>
  mutate(NB_EQUIP_TOTAL_DEP  = sum(NB_EQUIP)) |>
  select(DEP, NB_EQUIP, NB_EQUIP_TOTAL_DEP)
```
:::

::: {.column width="50%"}
```{.r}
# Source:   SQL [?? x 3]
# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1024-azure:R 4.3.2/:memory:]
# Groups:   DEP
   DEP   NB_EQUIP NB_EQUIP_TOTAL_DEP
   <chr>    <dbl>              <dbl>
 1 09           2               7316
 2 09           3               7316
# ‚Ñπ more rows
```
:::

::::
